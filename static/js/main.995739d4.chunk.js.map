{"version":3,"sources":["Node/Node.js","Algorithms/dijkstra.js","Main/Pathfinder.js","App.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","draggable","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","onDragStart","e","target","dataTransfer","setData","setTimeout","style","display","onDragOver","stopPropagation","children","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","console","log","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","useState","initialNodeRow","setInitialNodeRow","initialNodeCol","setInitialNodeCol","endNodeRow","setEndNodeRow","endNodeCol","setEndNodeCol","setGrid","mouseIsPressed","setMouseIsPressed","changeInitialNode","setchangeInitialNode","changeEndNode","setChangeEndNode","prevNode","setPrevNode","useEffect","getInitialGrid","changeInitialNodeNode","newGrid","slice","newNode","isDragging","changeEndNodeHandler","createNode","currentRow","getNewGridWithWallToggled","animateShortestPath","nodesInShortestPathOrder","i","document","getElementById","visualizeDijkstra","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","map","rowIdx","nodeIdx","onMouseDownHandler","onMouseEnterHandler","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.995739d4.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n\r\n    const dragStart = e => {\r\n      const target = e.target;\r\n      e.dataTransfer.setData('node_id', target.id);\r\n\r\n      setTimeout(() => {\r\n        target.style.display = 'none';\r\n      }, 0)\r\n\r\n    }\r\n\r\n    const dragOver = e => {\r\n      e.stopPropagation();\r\n    }\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      draggable,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n        ? 'node-start'\r\n        : isWall\r\n          ? 'node-wall'\r\n          : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        draggable={draggable}\r\n        onDragStart={dragStart}\r\n        onDragOver={dragOver}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}>{this.props.children}</div>\r\n    );\r\n  }\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  console.log('visitedNodesInOrder - ', visitedNodesInOrder)\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    console.log('node--distance==  ', closestNode.distance)\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  console.log('nodesInShortestPathOrder    ' ,nodesInShortestPathOrder)\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useEffect, useState } from 'react';\r\nimport Node from '../Node/Node';\r\nimport { dijkstra, getNodesInShortestPathOrder } from '../Algorithms/dijkstra';\r\n\r\nimport './Pathfinder.css';\r\n\r\n\r\nexport default function PathfindingVisualizer() {\r\n\r\n  const [initialNodeRow, setInitialNodeRow] = useState(10);\r\n  const [initialNodeCol, setInitialNodeCol] = useState(15);\r\n  const [endNodeRow, setEndNodeRow] = useState(10);\r\n  const [endNodeCol, setEndNodeCol] = useState(35);\r\n  const [grid, setGrid] = useState([]);\r\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n  const [changeInitialNode, setchangeInitialNode] = useState(false);\r\n  const [changeEndNode, setChangeEndNode] = useState(false);\r\n  const [prevNode, setPrevNode] = useState({ row: 0, col: 0 })\r\n\r\n\r\n  useEffect(() => {\r\n    setGrid(getInitialGrid)\r\n\r\n  }, [])\r\n\r\n  const onMouseDownHandler = (row, col) => {\r\n    console.log(grid)\r\n    if (row === initialNodeRow && col === initialNodeCol) {\r\n      console.log('initialrowmousedown', row, '  mousedown initialcol', col);\r\n\r\n      setPrevNode({ row: row, col: col });\r\n      setchangeInitialNode(true);\r\n      setMouseIsPressed(true);\r\n    } else if (row === endNodeRow && col === endNodeCol) {\r\n      setPrevNode({ row: row, col: col });\r\n      setChangeEndNode(true);\r\n      setMouseIsPressed(true);\r\n    } else {\r\n      console.log('row', row, '   col', col);\r\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n      setGrid(newGrid);\r\n      setMouseIsPressed(true);\r\n    }\r\n  }\r\n\r\n  const onMouseEnterHandler = (row, col) => {\r\n    if (!mouseIsPressed) {\r\n      if (changeInitialNode) {\r\n        setchangeInitialNode(!changeInitialNode)\r\n      }\r\n      else if (changeEndNode) {\r\n        setChangeEndNode(!changeEndNode)\r\n      }\r\n      return;\r\n    }\r\n    if (changeInitialNode) {\r\n      grid[prevNode.row][prevNode.col].isStart = false;\r\n      grid[row][col].isStart = true;\r\n      console.log('initialrow mouse enter', row, '   initialcol', col);\r\n      const newGrid = changeInitialNodeNode(grid, row, col);\r\n      setGrid(newGrid)\r\n      setPrevNode({ row: row, col: col });\r\n    } else if (changeEndNode) {\r\n      grid[prevNode.row][prevNode.col].isFinish = false;\r\n      grid[row][col].isFinish = true;\r\n      console.log('initialrow mouse enter', row, '   initialcol', col);\r\n      const newGrid = changeEndNodeHandler(grid, row, col);\r\n      setGrid(newGrid)\r\n      setPrevNode({ row: row, col: col });\r\n    } else {\r\n      console.log('else row', row, '  else col', col);\r\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n      setGrid(newGrid);\r\n\r\n    }\r\n  }\r\n\r\n  const onMouseUpHandler = () => {\r\n    setMouseIsPressed(false);\r\n    if (changeInitialNode) {\r\n      grid[initialNodeRow][initialNodeCol].isStart = true;\r\n      setchangeInitialNode(false);\r\n    }\r\n    if (changeEndNode) {\r\n      grid[endNodeRow][endNodeCol].isFinish = true;\r\n      setChangeEndNode(false);\r\n    }\r\n  }\r\n\r\n  const changeInitialNodeNode = (grid, row, col) => {\r\n    setInitialNodeRow(row);\r\n    setInitialNodeCol(col);\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: true,\r\n      isDragging: true\r\n    };\r\n\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  const changeEndNodeHandler = (grid, row, col) => {\r\n    setEndNodeRow(row);\r\n    setEndNodeCol(col);\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isFinish: true,\r\n      isDragging: true\r\n    };\r\n\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  const createNode = (col, row) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === initialNodeRow && col === initialNodeCol,\r\n      isFinish: row === endNodeRow && col === endNodeCol,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  };\r\n\r\n  const getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 50; col++) {\r\n        currentRow.push(createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  const getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        console.log('node distance from animateDijkstra  ', node.distance)\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  const animateShortestPath = (nodesInShortestPathOrder) => {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-shortest-path';\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  const visualizeDijkstra = () => {\r\n    const startNode = grid[initialNodeRow][initialNodeCol];\r\n    const finishNode = grid[endNodeRow][endNodeCol];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    console.log('visitedNodesInOrder from visualizeDijkstra  ', visitedNodesInOrder)\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    console.log('nodesInShortestPathOrder   ', nodesInShortestPathOrder);\r\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => visualizeDijkstra()}>\r\n        Find Shortest Path\r\n        </button>\r\n      <div className=\"grid\">\r\n        {grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const { row, col, isFinish, isStart, isWall } = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    onMouseDown={(row, col) => onMouseDownHandler(row, col)}\r\n                    onMouseEnter={(row, col) =>\r\n                      onMouseEnterHandler(row, col)\r\n                    }\r\n                    onMouseUp={() => onMouseUpHandler()}\r\n                    row={row}></Node>\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import './App.css';\n\nimport Pathfinder from './Main/Pathfinder';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n     <Pathfinder />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}